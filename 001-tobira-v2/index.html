<!DOCTYPE html>
<!--
Project: 避暑地への扉 — ノベルゲー風プロトタイプ
Author: <Cody@IT-journey>
Year: 2025
Demo: https://<YOUR-USERNAME>.github.io/<REPO-NAME>/
License: MIT（see LICENSE）

Third-party (via jsDelivr CDN, version pinned):
  - three.js r146 (MIT) © 2010–2025 three.js authors
    https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js
    https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js
    https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js

Assets:
  - Background images: Generated by AI by the author（詳細は ASSETS.md に記載）

Notes:
  - 展示・オフライン・CDNブロック環境では上記ファイルを vendor/ に同梱し、
    <script src="..."> の参照先をローカルに切り替えてください。
-->
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>避暑地への扉</title>
<!-- OGP / Twitter Card : ここから追記 -->
<!-- OGP / Twitter Card (v2, PNG版) -->
<meta property="og:title" content="避暑地への扉 — ノベルゲー風プロトタイプ">
<meta property="og:description" content="生成AI×単一HTMLで小説をノベルゲーム風に動かした最短プロトタイプ。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://tools001.github.io/note/001-tobira-v2/">
<meta property="og:image" content="https://tools001.github.io/note/001-tobira-v2/ogp.jpg">
<meta property="og:image:secure_url" content="https://tools001.github.io/note/001-tobira-v2/ogp.jpg">
<meta property="og:image:type" content="image/jpeg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:locale" content="ja_JP">
<meta property="og:site_name" content="tools001.github.io">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="避暑地への扉 — ノベルゲー風プロトタイプ">
<meta name="twitter:description" content="生成AI×単一HTMLで小説をノベルゲーム風に動かした最短プロトタイプ。">
<meta name="twitter:image" content="https://tools001.github.io/note/001-tobira-v2/ogp.jpg">
<link rel="canonical" href="https://tools001.github.io/note/001-tobira-v2/">
<!-- OGP / Twitter Card : ここまで -->
<style>
  :root{ --bg:#07070a; --fg:#eaeef7; }
  html,body{
    margin:0;height:100%;
    background:var(--bg);color:var(--fg);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Yu Gothic",Meiryo,sans-serif;
    overflow:hidden;
    overscroll-behavior:none;
    touch-action:none;                 /* 自前ジェスチャ */
    -webkit-user-select:none; user-select:none;
    -webkit-tap-highlight-color:transparent;
  }
  canvas{ display:block; touch-action:none; -webkit-tap-highlight-color:transparent; }

  /* レイヤー：canvas(0) < tapAll(1) < HUD(3) */
  .hud{position:fixed;inset:0;pointer-events:none; z-index:3;}
  #tapAll{position:fixed;inset:0; z-index:1; pointer-events:auto;} /* 全画面タップ用 */

  .top{position:absolute;left:12px;top:10px;right:12px;display:flex;gap:8px;align-items:center;opacity:.9}
  .chip{pointer-events:auto;border:1px solid #333;padding:6px 10px;border-radius:999px;font-size:12px;background:#1116}
  .log{margin-left:auto;font-size:12px;opacity:.75}

  /* 右上類を非表示 */
  #sceneChip{ display:none; }
  #fps{ display:none; }
  #log{ display:none; }

  .panel{
    position:absolute;left:0;right:0;bottom:0;
    padding:18px 16px 24px;
    background:linear-gradient(180deg,#0000,#0006 40%,#0009);
    pointer-events:auto;
    z-index:3;
  }
  .textbox{
    max-width:min(980px,92vw);
    margin:0 auto;
    padding:14px 18px;
    border:1px solid #1b1f28;border-radius:14px;
    background:rgba(11,13,18,.35);          /* 半透明 */
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    box-shadow:0 8px 24px rgba(0,0,0,.25);
    font-size:16px;line-height:1.9;

    display:grid;
    grid-template-rows: 1.4em auto auto;
    row-gap:10px;
    align-items:start;
    -webkit-user-select:none; user-select:none;
  }
  .speaker{ opacity:.85;font-size:13px;line-height:1.4em; min-height:1.4em; }
  #text{ margin:0; white-space:pre-wrap; word-break:break-word; }

  .controls{display:flex;gap:14px;justify-content:flex-end}
  .btn{
    pointer-events:auto;border:1px solid #2a2a2a;background:#101318;
    padding:16px 24px;border-radius:14px;color:var(--fg);
    font-weight:600;letter-spacing:.02em;cursor:pointer;transition:.18s;
    font-size:18px;min-height:48px;
    -webkit-user-select:none; user-select:none;
    touch-action:none;
  }
  .btn:hover{transform:translateY(-1px);box-shadow:0 6px 16px #0006}

  .vignette{position:fixed;inset:-3px;background:radial-gradient(ellipse at center,#0000 45%,#0004 70%,#0009 100%);pointer-events:none; z-index:2;}
  @media (max-width:600px){
    .textbox{font-size:15px; grid-template-rows: 1.4em auto auto;}
  }
</style>
</head>
<body>
<div id="tapAll" aria-hidden="true"></div>

<div class="hud">
  <div class="top">
    <div class="chip" id="sceneChip">Scene: --</div>
    <div class="chip" id="fps">FPS: --</div>
    <div class="log" id="log">読み込み中…</div>
  </div>
  <div class="panel">
    <div class="textbox">
      <div class="speaker" id="speaker"></div>
      <div id="text"></div>
      <div class="controls">
        <button class="btn" id="prevBtn">◀ 戻る</button>
        <button class="btn" id="nextBtn">次へ ▶</button>
      </div>
    </div>
  </div>
  <div class="vignette"></div>
</div>

<!-- Three.js r146（グローバル） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ================= ASSETS =================
const ASSETS = { doorModel:null, benchModel:null };
// ==========================================

// ---------- Three.js 基本セット ----------
const renderer = new THREE.WebGLRenderer({antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMappingExposure = 1;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x06070a);
scene.fog = new THREE.FogExp2(0x06070a, 0.02);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 1.6, 6);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.enablePan = false; controls.minDistance = 1.2; controls.maxDistance = 12;

const clock = new THREE.Clock();

// Lights
const hemi = new THREE.HemisphereLight(0x7ea6ff, 0x101018, 0.6); scene.add(hemi);
const key  = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(4,6,3); scene.add(key);

// Ground（STREETでは非表示。DESCENT/DOOR/ONEYEARで使用）
const groundMat = new THREE.MeshStandardMaterial({color:0x111317, roughness:0.98});
const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), groundMat);
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

// テクスチャローダ
const texLoader = new THREE.TextureLoader();
const streetBgTex   = texLoader.load('machi.jpg',     (t)=>{ t.encoding=THREE.sRGBEncoding; t.minFilter=THREE.LinearFilter; });
const highlandBgTex = texLoader.load('hisyochi.jpg',  (t)=>{ t.encoding=THREE.sRGBEncoding; t.minFilter=THREE.LinearFilter; });
const nightBgTex    = texLoader.load('hisyochi1.jpg', (t)=>{ t.encoding=THREE.sRGBEncoding; t.minFilter=THREE.LinearFilter; });
const descentBgTex  = texLoader.load('hisyochi2.jpg', (t)=>{ t.encoding=THREE.sRGBEncoding; t.minFilter=THREE.LinearFilter; });

// ---- モヤ粒子（STREETでは非表示） ----
const motes = makeMotes(260); scene.add(motes);

// ---- 吹雪（白い丸パーティクル） ----
const circleTex = makeCircleTexture(64);
const snow = makeSnow(1400, circleTex);
snow.visible = false; scene.add(snow);

// GLTF（扉＆ベンチ）
const loader = new THREE.GLTFLoader();
let doorObj, doorPivot, benchObj;

(async function ensureModels(){
  if(ASSETS.doorModel){ doorObj = (await loadGLB(ASSETS.doorModel)).scene; }
  else{
    doorObj = new THREE.Mesh(
      new THREE.BoxGeometry(1,2,0.08),
      new THREE.MeshStandardMaterial({color:0xcad5ff, metalness:.1, roughness:.2, emissive:0x112244})
    );
  }
  doorPivot = new THREE.Group();
  doorPivot.position.set(-0.45, 1, -2);    // ★ ドアのX位置 = -0.45（指定）
  doorObj.position.set(0.5, 0, 0);         // 左ヒンジ（右ヒンジにしたい時は -0.5）
  doorPivot.add(doorObj);
  doorPivot.visible = false;
  scene.add(doorPivot);

  if(ASSETS.benchModel){ benchObj = (await loadGLB(ASSETS.benchModel)).scene; }
  else{ benchObj = makeBench(); }
  benchObj.visible = false; scene.add(benchObj);
})();

function loadGLB(url){ return new Promise((res,rej)=> loader.load(url, res, undefined, rej)); }

// ---------- 形状ユーティリティ ----------
function makeMotes(n=200){
  const geo = new THREE.BufferGeometry();
  const arr = new Float32Array(n*3);
  for(let i=0;i<n;i++){
    const r = Math.random()*16+2, a = Math.random()*Math.PI*2;
    arr[i*3+0] = Math.cos(a)*r;
    arr[i*3+1] = Math.random()*2.4 + .2;
    arr[i*3+2] = Math.sin(a)*r;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
  return new THREE.Points(geo, new THREE.PointsMaterial({size:0.04, transparent:true, opacity:.6, depthWrite:false}));
}

function makeCircleTexture(size=64){
  const c = document.createElement('canvas'); c.width=c.height=size;
  const ctx = c.getContext('2d');
  const r = size*0.45, cx = size/2, cy = size/2;
  const g = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r);
  g.addColorStop(0, 'rgba(255,255,255,1)');
  g.addColorStop(0.6, 'rgba(255,255,255,0.85)');
  g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.clearRect(0,0,size,size);
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  return tex;
}

function makeSnow(count=1200, mapTex){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const vel = new Float32Array(count*3);
  const R = 22;
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const r = Math.sqrt(Math.random())*R;
    pos[i*3+0] = Math.cos(a)*r;
    pos[i*3+2] = Math.sin(a)*r;
    pos[i*3+1] = Math.random()*8 + 2;
    vel[i*3+0] = (Math.random()*0.2-0.1);
    vel[i*3+1] = -(Math.random()*0.6+0.4);
    vel[i*3+2] = (Math.random()*0.2-0.1);
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.userData.vel = vel;
  const mat = new THREE.PointsMaterial({ size:0.08, map:mapTex, transparent:true, alphaTest:0.08, opacity:0.95, depthWrite:false });
  const pts = new THREE.Points(geo, mat);
  pts.userData.params = { windX: 0.4, fall: 0.8, turb: 0.8 };
  return pts;
}

function makeBench(){
  const group = new THREE.Group();
  const wood = new THREE.MeshStandardMaterial({color:0x6c553a, roughness:.8});
  const metal= new THREE.MeshStandardMaterial({color:0x555, metalness:.7, roughness:.4});
  for(let i=0;i<4;i++){
    const plank = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.08,0.22), wood);
    plank.position.set(0,0.5+i*0.09,-0.2); group.add(plank);
  }
  const legGeo = new THREE.CylinderGeometry(0.03,0.03,0.6,12);
  const l1 = new THREE.Mesh(legGeo, metal); l1.position.set(-0.55,0.3,-0.3);
  const l2 = l1.clone(); l2.position.x=0.55; group.add(l1,l2);
  group.position.set(-1.4,0,-1.5);
  return group;
}

// ---------- 物語 ----------
const SCENES = {
  STREET:'STREET', DOOR:'DOOR', HIGHLAND:'HIGHLAND', NIGHT:'NIGHT',
  DESCENT:'DESCENT', ONEYEAR:'ONEYEAR', END:'END'
};

const NARRATIVE = {
[SCENES.STREET]: [
{t:"僕の名前は佐藤悠人（さとう・ゆうと）。十五歳の夏、あの日の暑さを、僕は一生忘れられない。", s:"悠人"},
{t:"夏休みの最終日、親友の中村亮（なかむら・りょう）と一緒に、部活帰りに本屋へ寄る予定だった。"},
{t:"去年までは、もう一人そこにいた。僕と亮がそろって好意を寄せていた女子――佐々木美奈（ささき・みな）。"},
{t:"けれど彼女は昨夏、熱中症で突然亡くなった。"},
{t:"取り合いの末に失ってしまった存在。僕と亮はまた友人として並ぶようになったが、気まずさは残った。"},
{t:"その日は異常だった。アスファルトは歪み、街路樹の影すら役に立たない。気温は40度を超え、蝉の声さえ狂気じみて聞こえた。"},
{t:"「悠人、先にコンビニ寄って飲み物買ってくるわ。喉が死にそう」", s:"亮"},
{t:"「わかった。じゃあ本屋の前で集合な」", s:"悠人"},
],
[SCENES.DOOR]: [
{t:"ふと横の路地に白い靄がゆらめく。そこだけ空気が冷えているように見えた。"},
{t:"――ひんやりとした風。冷たい扉が、場違いにそこへ据えられていた。"},
{t:"扉の周りには涼を求める人が集まっていた。皆、吸い寄せられるように近づき、開くのを待っている。"},
{t:"僕も一歩踏み出しかけて、ふと足が止まる。ギィィ……と音を立て、扉がひとりでに開いた。"},
{t:"次の瞬間、ドンッ！ 背中を強く押され、僕は中へ吸い込まれた。"},
{t:"最後に感じたのは――背中に触れた手の、異様な冷たさだった。"},
],
[SCENES.HIGHLAND]: [
{t:"そこは灼熱の街ではなかった。眼前には高原の避暑地が広がっていた。"},
{t:"木陰の下には涼やかな風、澄んだ小川がきらめき、岩にあたる水音が心地よい旋律のように響く。"},
{t:"「涼しい……！」思わず声をあげ、疑念も恐怖も忘れて駆け回る。", s:"悠人"},
],
[SCENES.NIGHT]: [
{t:"やがて夕暮れ。時計では数分しか経っていないのに、空は茜色に染まっていた。時間の感覚が狂っている。"},
{t:"茜の名残が薄れる散策路の端、ささくれた木枠の掲示板がこちらを向いていた。"},
{t:"〈避暑地案内〉 ― 扉は真夏の極暑の日にだけ開く。訪れた者は涼を得られる。ただし長居は禁物……"},
{t:"― 戻る道はひとつ。次の夏、扉が開いたとき、現世の者を一人送り込むこと。 ― 入れ替わりは“縁ある者”に限る。"},
{t:"掲示板には古びた紙が何枚も貼られていた。"},
{t:"〈冥府新報・過去記事抜粋〉「高校生・川村明彦（17）、部活動中に倒れ死亡」"},
{t:"「主婦・長谷川絹子（42）、帰宅途中に路上で倒れ死亡」"},
{t:"「会社員・斎藤真司（32）、河川敷で意識失い死亡」"},
{t:"「中学生・佐々木美奈（14）、自宅で死亡。エアコン故障か」"},
{t:"記事には続きがあった。「修理依頼は出されておらず、窓も開けられていなかったという」……それはもう、事故ではなかった。"},
{t:"足元の小川は鏡のように静まり、まるで“境界”のようだ。"},
],
[SCENES.DESCENT]: [
{t:"避暑地は次第におかしくなっていく。冷気は鋭く肺を突き、風は骨の芯まで凍みる。陽は沈まず、薄暗さだけが永遠に続く。"},
{t:"心地よさは偽りで、この場所は地獄だった。耐え難い寒さと暗闇に、心は削られていく。"},
{t:"悪いと分かっていても、罪悪感は次第に薄れていく。　――戻りたい。美奈の真意を確かめたい。誰かを、代わりに。"},
{t:"頭の隙間で、美奈が囁く。「どちらも選べなかったの」", s:"美奈の声"},
{t:"親の顔。妹の笑顔。亮との日々。誰か一人を思い浮かべるたび、心臓を握りつぶされるような苦しみが走る。"},
{t:"いっそ、自分がここで凍りつけばいいのかもしれない。だが、冷気はいずれ正気を奪ってしまう。"},
],
[SCENES.ONEYEAR]: [
{t:"――一年が経った。扉が再び開く。"},
{t:"そこには、汗だくで路地に迷い込んだ懐かしい姿があった。"},
{t:"僕はゆっくりと手を伸ばす。掌に触れる、確かな温もり。"},
{t:"その温もりは、かつて僕が守りたかった誰かのものと同じだった。けれど次の夏には、もう別の誰かのものになっているのだろう。"},
],
[SCENES.END]: [
{t:"――END――"}
]
};

// ---------- UI ----------
const $ = id=>document.getElementById(id);
const speakerEl = $('speaker'), textEl = $('text');
const nextBtn = $('nextBtn'), prevBtn = $('prevBtn');
const fpsEl = $('fps'), logEl = $('log'), sceneChip = $('sceneChip');
const tapAll = $('tapAll');
const panelEl = document.querySelector('.panel');

let order = [SCENES.STREET, SCENES.DOOR, SCENES.HIGHLAND, SCENES.NIGHT, SCENES.DESCENT, SCENES.ONEYEAR, SCENES.END];
let curScene = order[0], lineIdx = 0;
let lastScene = null;

function setSceneLabel(){ sceneChip.textContent = `Scene: ${curScene}`; }
function setLog(msg){ logEl.textContent = msg; }
function setLine(entry){ speakerEl.textContent = entry.s ? `【${entry.s}】` : ''; textEl.textContent = entry.t; }

// ---------- ナビ（デバウンス） ----------
let lastNavAt = 0;
function navDebounce(fn){
  const now = performance.now();
  if(now - lastNavAt < 220) return;
  lastNavAt = now;
  fn();
}
function goNext(){ navDebounce(()=>advance(+1)); }
function goPrev(){ navDebounce(()=>advance(-1)); }

// ---------- 進む／戻る ----------
function advance(dir=+1){
  const arr = NARRATIVE[curScene];
  const goingForward = dir > 0;
  lineIdx += dir;

  if(lineIdx>=0 && lineIdx<arr.length){
    setLine(arr[lineIdx]);
    if(lineIdx===0 && goingForward) enterEffects(curScene, true);

    // DOOR：「ギィィ……」で開扉（進む時のみ）＋最後から2行目でパンチイン
    if(curScene===SCENES.DOOR && goingForward){
      const line = arr[lineIdx]?.t || "";
      if(line.includes("ギィィ")) openDoor();
      if(lineIdx === NARRATIVE[SCENES.DOOR].length - 2){
        cameraPunchToDoor();
      }
    }
    // ONEYEAR：1行目テキストで開扉（進む時のみ）
    if(curScene===SCENES.ONEYEAR && goingForward){
      const line = arr[lineIdx]?.t || "";
      if(line.includes("扉が再び開く")) openDoor();
    }
  }else{
    const idx = order.indexOf(curScene) + (goingForward?1:-1);
    if(idx>=0 && idx<order.length){
      lastScene = curScene;
      curScene = order[idx];
      lineIdx = (goingForward?0:Math.max(0, NARRATIVE[curScene].length-1));
      setSceneLabel(); setLine(NARRATIVE[curScene][lineIdx]);
      enterEffects(curScene, true);

      // シーン切替直後（行0）の一年後オープンを前進時のみ発火
      if(goingForward && curScene===SCENES.ONEYEAR){
        const first = NARRATIVE[curScene][lineIdx]?.t || "";
        if(first.includes("扉が再び開く")) openDoor();
      }
      window.scrollTo(0,0);
    }else{
      lineIdx = Math.max(0, Math.min(arr.length-1, lineIdx));
    }
  }
}

// ---------- 入力（Pointerに一本化） ----------
let tsX=0, tsY=0, t0=0;
function isFromButton(e){
  const path = e.composedPath ? e.composedPath() : [];
  return path.some(el => el && el.classList && el.classList.contains('btn'));
}
function onPD(e){
  const t = e;
  tsX = t.clientX; tsY = t.clientY; t0 = performance.now();
}
function onPU(e, origin){
   if(e.cancelable) e.preventDefault(); 
  // ボタン由来はここでは処理しない
  if(isFromButton(e)) return;

  const dx = e.clientX - tsX;
  const dy = e.clientY - tsY;
  const dt = performance.now() - t0;

  if(Math.abs(dx)>50 && Math.abs(dx)>Math.abs(dy)){
    dx<0 ? goNext() : goPrev();
  }else if(dt<300 && Math.abs(dx)<10 && Math.abs(dy)<10){
    goNext();
  }
}
// 全画面とパネルで pointer を監視（click/touch は使わない）
tapAll.addEventListener('pointerdown', onPD);
tapAll.addEventListener('pointerup',   (e)=>onPU(e,'all'));
panelEl.addEventListener('pointerdown', onPD);
panelEl.addEventListener('pointerup',   (e)=>onPU(e,'panel'));

// ボタンは専用の pointerup で確実に制御（バブリング停止）
nextBtn.addEventListener('pointerup', (e)=>{ e.stopPropagation(); if(e.cancelable) e.preventDefault(); goNext(); });
prevBtn.addEventListener('pointerup', (e)=>{ e.stopPropagation(); if(e.cancelable) e.preventDefault(); goPrev(); });

// ---------- 雷光フラッシュ ----------
const lightning = { active:false, time:0, dur:0.35, hemiBase:0.6, hemiPeak:1.9, exposureBase:1.0, exposurePeak:1.8 };
function triggerLightning(){
  lightning.active = true; lightning.time = 0;
  lightning.hemiBase = hemi.intensity; lightning.exposureBase = renderer.toneMappingExposure;
}

// ---------- シーン演出 ----------
function enterEffects(name){
  switch(name){
    case SCENES.STREET:  heatStreet(); break;
    case SCENES.DOOR:    doorCold(); cameraFly(new THREE.Vector3(0,1.4,3.2), new THREE.Vector3(0,1.1,-1.2)); break;
    case SCENES.HIGHLAND:toHighland(); break;
    case SCENES.NIGHT:   toNight(); break;
    case SCENES.DESCENT:
      if(lastScene === SCENES.NIGHT) triggerLightning();
      descentColdNoPhoto(); startBlizzard(); break;
    case SCENES.ONEYEAR: returnDoor(); cameraFly(new THREE.Vector3(0,1.5,3.0), new THREE.Vector3(0,1.1,-1.3)); break;
    case SCENES.END:     fadeToBlack(); break;
  }
}

// STREET：写真のみ
function heatStreet(){
  setLog('灼熱の街：写真のみ（地面/モヤなし）');
  scene.background = streetBgTex;
  scene.fog.density = 0.0;

  ground.visible = false; motes.visible = false;
  if(benchObj) benchObj.visible = false;
  if(doorPivot) doorPivot.visible = false;

  key.intensity = 1.0; key.color.set(0xfff0c9);
  hemi.intensity = 0.5; hemi.color.set(0xffd8aa); hemi.groundColor.set(0x22150f);

  snow.visible = false;
}
// DOOR：色背景＋扉出現
function doorCold(){
  setLog('冷たい扉が現れる');
  scene.background = new THREE.Color(0x0c0f14);
  scene.fog.density = 0.022; scene.fog.color.set(0x0c0f14);

  ground.visible = true; motes.visible = true;

  if(doorPivot){ doorPivot.visible = true; doorPivot.rotation.set(0,0,0); }
  if(doorObj && doorObj.material){
    doorObj.material.emissive = new THREE.Color(0x88aaff);
    doorObj.material.emissiveIntensity = 0.6;
  }
  doorState.opening = false; doorState.opened = false;

  if(benchObj) benchObj.visible = false;

  key.intensity = 0.9; key.color.set(0xcfe9ff);
  hemi.intensity = 0.55; hemi.color.set(0x9fefff); hemi.groundColor.set(0x0c0f14);
  snow.visible = false;
}
// HIGHLAND（昼）：写真のみ
function toHighland(){
  setLog('高原（昼）：写真背景 hisyochi.jpg');
  scene.background = highlandBgTex; scene.fog.density = 0.0;

  ground.visible = false; motes.visible = false;
  if(benchObj) benchObj.visible = false; if(doorPivot) doorPivot.visible = false;

  hemi.intensity = 0.45; hemi.color.set(0xb4ffd0); hemi.groundColor.set(0x1a2d1d);
  key.intensity  = 0.6;  key.color.set(0xe9fff3);

  snow.visible = false;
}
// NIGHT：写真のみ
function toNight(){
  setLog('高原（夜）：写真背景 hisyochi1.jpg');
  scene.background = nightBgTex; scene.fog.density = 0.0;

  ground.visible = false; motes.visible = false;
  if(benchObj) benchObj.visible = false; if(doorPivot) doorPivot.visible = false;

  hemi.intensity = 0.35; hemi.color.set(0xa8d3ff); hemi.groundColor.set(0x142026);
  key.intensity  = 0.4;  key.color.set(0xcfe5ff);

  snow.visible = false;
}
// DESCENT：写真＋吹雪（地面なし）
function descentColdNoPhoto(){
  setLog('地獄の寒気：写真（hisyochi2.jpg）＋吹雪');
  scene.background = descentBgTex;
  scene.fog.color.set(0x0a0f14); scene.fog.density = 0.04;

  ground.visible = false; motes.visible = false;
  if(benchObj) benchObj.visible = false; if(doorPivot) doorPivot.visible = false;

  key.intensity = 0.6; key.color.set(0xbfdcff);
  hemi.intensity = 0.4; hemi.color.set(0x9fb9ff); hemi.groundColor.set(0x0a0f14);
}
// ONEYEAR：写真なし＋扉再登場（状態リセット）
function returnDoor(){
  setLog('一年後：扉は再び開く（写真なし）');
  scene.background = new THREE.Color(0x0c0f14);
  scene.fog.density = 0.022; scene.fog.color.set(0x0c0f14);

  ground.visible = true; motes.visible = true;

  if(doorPivot){ doorPivot.visible = true; doorPivot.rotation.set(0,0,0); }
  if(doorObj && doorObj.material){
    doorObj.material.emissive = new THREE.Color(0x88aaff);
    doorObj.material.emissiveIntensity = 0.6;
  }
  doorState.opening = false; doorState.opened = false;

  if(benchObj) benchObj.visible = false;

  key.intensity = 0.85; key.color.set(0xe9f3ff);
  hemi.intensity = 0.5; hemi.color.set(0xbad3ff); hemi.groundColor.set(0x0c0f14);

  snow.visible = false;
}
function fadeToBlack(){
  setLog('終幕');
  scene.background = new THREE.Color(0x000000);
  let t=0; (function fade(){
    t+=0.02; scene.fog.density = THREE.MathUtils.lerp(scene.fog.density, 0.12, 0.05);
    if(t<1.2) requestAnimationFrame(fade);
  })();
}

// ---- 扉を開く（左ヒンジ回転） ----
const doorState = { opening:false, opened:false };
function openDoor(){
  if(!doorPivot || doorState.opened || doorState.opening) return;
  doorState.opening = true;

  const start = performance.now();
  const dur = 800;
  const from = 0;
  const to   = -Math.PI * 2/3; // -120°

  if(doorObj && doorObj.material) doorObj.material.emissiveIntensity = 0.9;

  function step(now){
    const u = Math.min(1, (now - start)/dur);
    const e = 1 - Math.pow(1-u, 3);
    doorPivot.rotation.y = from + (to - from) * e;
    if(u < 1){
      requestAnimationFrame(step);
    }else{
      doorState.opening = false;
      doorState.opened  = true;
      if(doorObj && doorObj.material) doorObj.material.emissiveIntensity = 0.6;
    }
  }
  requestAnimationFrame(step);
}

// ---- 吹雪開始（強度一気盛り） ----
function startBlizzard(){
  snow.visible = true;
  const p = snow.userData.params;
  p.windX = 3.2; p.fall = 6.0; p.turb = 4.0;
  snow.material.size = 0.14;
}

// Camera 微Tween
let camTween=null;
function cameraFly(pos, look){
  const startP = camera.position.clone(), startT = controls.target.clone();
  const endP = pos.clone(), endT = look.clone(); const dur = 1.2; let t=0;
  camTween = function run(){
    const dt=clock.getDelta(); t+=dt; const k=Math.min(1,t/dur); const e=ease(k);
    camera.position.lerpVectors(startP,endP,e); controls.target.lerpVectors(startT,endT,e);
    if(k<1) requestAnimationFrame(camTween); else camTween=null;
  }; requestAnimationFrame(camTween);
}
function ease(x){ return x<0.5?4*x*x*x:1-Math.pow(-2*x+2,3)/2; }

// ---- 扉へパンチイン（固定座標を狙う。完了後に扉を非表示） ----
function cameraPunchToDoor(){
  const startP = camera.position.clone();
  const startT = controls.target.clone();

  // ★ 固定座標（以前のまま）
  const endP = new THREE.Vector3(0, 1.25, -0.6);  // カメラ位置
  const endT = new THREE.Vector3(0, 1.1,  -2.0);  // 注視点

  const durMs  = 550, t0 = performance.now();
  const prevEnabled = controls.enabled;
  controls.enabled = false;

  function run(){
    const u = Math.min(1, (performance.now() - t0) / durMs);
    const e = 1 - Math.pow(1 - u, 3); // easeOutCubic
    camera.position.lerpVectors(startP, endP, e);
    controls.target.lerpVectors(startT, endT, e);
    if(u < 1){
      requestAnimationFrame(run);
    } else {
      controls.enabled = prevEnabled;
      if (doorPivot) doorPivot.visible = false; // パンチイン後に扉を消す
    }
  }
  requestAnimationFrame(run);
}

// ---------- 進行開始 ----------
setSceneLabel(); setLine(NARRATIVE[curScene][0]); enterEffects(curScene);

// ---------- ループ ----------
let lastMeter = 0;
function loop(){
  requestAnimationFrame(loop);
  const dt = clock.getDelta();
  const t  = clock.elapsedTime;

  if(lightning.active){
    lightning.time += dt;
    const u = Math.min(lightning.time / lightning.dur, 1);
    const k = 1 - u;
    const w = k*k*(2 - k);
    hemi.intensity = lightning.hemiBase + (lightning.hemiPeak - lightning.hemiBase) * w;
    renderer.toneMappingExposure = lightning.exposureBase + (lightning.exposurePeak - lightning.exposureBase) * w;
    if(u >= 1){
      lightning.active = false;
      hemi.intensity = lightning.hemiBase;
      renderer.toneMappingExposure = lightning.exposureBase;
    }
  }

  updateMotes(t);
  updateSnow(t, dt);
  if(controls.enabled) controls.update();
  renderer.render(scene,camera);

  const now = performance.now();
  if(now-lastMeter>500){
    const fps = (1/dt).toFixed(0);
    fpsEl.textContent = `FPS: ${fps}`; lastMeter = now;
  }
}
loop();

function updateMotes(t){
  const pos = motes.geometry.attributes.position;
  for(let i=0;i<pos.count;i++){
    const ix=i*3, x=pos.array[ix], y=pos.array[ix+1], z=pos.array[ix+2];
    const mode = (curScene===SCENES.STREET||curScene===SCENES.DOOR)?'HOT':'COLD';
    const w = mode==='HOT' ? Math.sin(t*2.0 + x*1.1 + z*0.8)*0.006 : Math.sin(t*0.7 + x*0.6 + z*0.5)*0.003;
    pos.array[ix+1] = y + w;
  }
  pos.needsUpdate = true;
}

function updateSnow(t, dt){
  if(!snow.visible) return;
  const geo = snow.geometry;
  const pos = geo.attributes.position.array;
  const vel = geo.userData.vel;
  const p   = snow.userData.params;
  const R = 24;

  for(let i=0;i<vel.length/3;i++){
    const i3 = i*3;
    const turbX = (Math.sin(t*1.7 + pos[i3+2]*0.12 + i*0.13))*p.turb*0.3;
    const turbZ = (Math.cos(t*1.3 + pos[i3]*0.11 + i*0.17))*p.turb*0.25;

    pos[i3+0] += (vel[i3+0] + p.windX*0.6 + turbX) * dt;
    pos[i3+1] += (vel[i3+1] - p.fall) * dt;
    pos[i3+2] += (vel[i3+2] + turbZ) * dt;

    if(pos[i3+1] < -0.5){
      const a = Math.random()*Math.PI*2;
      const r = Math.sqrt(Math.random())*R;
      pos[i3+0] = Math.cos(a)*r;
      pos[i3+2] = Math.sin(a)*r;
      pos[i3+1] = Math.random()*6 + 4;
      vel[i3+0] = (Math.random()*0.2-0.1);
      vel[i3+1] = -(Math.random()*0.6+0.4);
      vel[i3+2] = (Math.random()*0.2-0.1);
    }
  }
  geo.attributes.position.needsUpdate = true;
}

// ---------- 入出力 ----------
function onResize(){
  const w=innerWidth, h=innerHeight;
  renderer.setSize(w,h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  window.scrollTo(0,0);
}
window.addEventListener('resize', onResize);
window.addEventListener('orientationchange', ()=>{ setTimeout(onResize, 200); });

document.addEventListener('keydown',(e)=>{
  if(e.key==='ArrowRight'||e.key===' '){ goNext(); }
  if(e.key==='ArrowLeft'){ goPrev(); }
});
</script>
</body>
</html>
